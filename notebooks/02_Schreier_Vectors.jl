### A Pluto.jl notebook ###
# v0.19.0

using Markdown
using InteractiveUtils

# ╔═╡ 694eedcf-fc88-4c98-a508-49d51e95e307
"""
    orbit_plain(S, x[, action=^])
Compute the orbit of `x` under the action of a group `G` generated by set `S`.

It is assumed that elements `g ∈ G` act on `x` via `action(x, g)`.

### Input
 * `G` - a group with finite generating set
 * `x` - a point
 * `action` - a function defining action from the right, defaulting to `^`.
### Output
 * `{xᵍ | g ∈ G}` - the orbit of `x` under the action of `G`, returned as a `Vector`.
"""
function orbit_plain(S, x, action=^)
    @assert !isempty(S) # groups need generators
	Δ = [x]
	Δset = Set(Δ) 
    for δ in Δ
        for s in S
            γ = action(δ, s)
            if γ ∉ Δset
				push!(Δset, γ)
                push!(Δ, γ)
            end
        end
    end
    return Δ
end

# ╔═╡ b1c7b4d8-c3d8-11ec-1936-2bbc4338d17a
begin
"""
    AbstractPermutation
Abstract type representing permutations of the set `1:n`.

Subtypes `Perm <: AbstractPermutation` must implement the following functions:
* `(σ::Perm)(i::Integer)` - return the image of `i` under `σ`,
* `degree(σ::Perm)` - return `n` such that `σ(k) == k` for all `k > n`,
* `Perm(images[, check::Bool=true])` - construct a `Perm` from a vector of images,
Optionally the second argument `check=false` may be passed when the caller
knows that `images` constitute a honest permutation.
"""
abstract type AbstractPermutation end

"""
    degree(σ::AbstractPermutation)
Return a minimal number `n` such that `σ(k) == k` for all `k > n`.

Such number `n` can be understood as a _degree_ of a permutation, since we can regard
`σ` as an element of `Sym(n)`.
"""
function degree end

Base.one(σ::P) where P<:AbstractPermutation = P(Int[], false)

function Base.inv(σ::P) where P<:AbstractPermutation
    img = collect(1:degree(σ))
    for i in 1:degree(σ)
        img[σ(i)] = i
    end
    return P(img, false)
end

function Base.:(*)(σ::P, τ::AbstractPermutation) where P<:AbstractPermutation
    deg = max(degree(σ), degree(τ))
    img = collect(1:deg)
    for i in 1:deg
        img[i] = τ(σ(i))
    end
    return P(img, false)
end

function Base.:(==)(σ::AbstractPermutation, τ::AbstractPermutation)
    deg = max(degree(σ), degree(τ))
    for i in 1:deg
        if σ(i) != τ(i)
            return false
        end
    end
    return true
end

function Base.hash(σ::AbstractPermutation, h::UInt)
	h = hash(typeof(σ), h)
	 # this is truly correct only if degree is minimal!
	for i in 1:degree(σ)
		h = hash(σ(i), h)
	end
	return h
end

function Base.show(io::IO, σ::AbstractPermutation)
    is_trivial = true
    for cycle in cycle_decomposition(σ)
        if length(cycle) == 1
            continue
        else
            is_trivial = false
            print(io, "(")
            join(io, cycle, ",")
            print(io, ")")
        end
    end
    if is_trivial
        print(io, "()")
    end
end

function cycle_decomposition(σ::AbstractPermutation)
    visited = falses(degree(σ))
    cycles = Vector{Vector{Int}}()
    # each cycle will be a Vector{Int} and we have a whole bunch of them
    for i in 1:degree(σ)
        if visited[i]
            # if we have already seen this point there is no point in computing
            # the same orbit twice
            continue # i.e. skip the rest of the body and continue with the next i
        end
        Δ = orbit_plain(σ, i, ^)
        visited[Δ] .= true # modify the `visited` along the whole orbit
        push!(cycles, Δ) # add obtained orbit to cycles
    end
    return cycles
end

function orbit_plain(s::AbstractPermutation, x, action=^)
	Δ = [x]
	Δset = Set(Δ)
    for δ in Δ
        γ = action(δ, s)
        if γ ∉ Δset
			push!(Δset, γ)
            push!(Δ, γ)
        end
    end
    return Δ
end

Base.:^(i::Integer, σ::AbstractPermutation) = σ(i)

AbstractPermutation
end

# ╔═╡ 423e67fc-a756-4ba7-8e4d-fabfb7e22045
begin
	struct Permutation <: AbstractPermutation
		images::Vector{Int}
	
		function Permutation(v::Vector{<:Integer}, check=true)
			if check
				@assert sort(v) == 1:length(v) "Image vector doesn't define a permutation"
			end
			return new(v)
		end
	end
	
	## Interface of AbstractPermutation
	(σ::Permutation)(n::Integer) = (n > length(σ.images) ? n : σ.images[n])
	
	degree(σ::Permutation) =
	    something(findlast(i->σ.images[i]!=i, 1:length(σ.images)), 0)
end

# ╔═╡ 57982949-1cb9-4077-afd7-444fb42f0fec
methods(degree)

# ╔═╡ 261f2777-c2cc-498e-a7ef-a819f779344c
σ = Permutation([2,1,3])

# ╔═╡ 9b3ef828-f64c-42b5-a7d8-ed7d2e0f96a9
τ = Permutation([1,3,2])

# ╔═╡ 18121dc3-78d2-4334-b1bb-9b3cba02d730
σ*τ

# ╔═╡ 4118ac8d-3e55-4717-ac1f-98a3446b5eff
md"
>**Exercise 1**:
>1. Create `struct CyclePermutation <: AbstractPermutation` that stores `cycles::Vector{Vector{Int}}` in its fields.
>2. Implement the `AbstractPermutation` interface i.e. `degree` and obtaining the image of `i::Integer` under such permutation.
>3. Verify the correctness of multiplication, inversion etc. by writing appropriate `begin ... end`  block with `@assert`s.
>4. What happens if we multiply `CyclePermutation` and `Permutation` together? Can you find where does this behaviour come from?

>**Exercise 2**: (_Advanced_)
>1. Write a function that takes a string representing a permutation in its cycle form, e.g. `\"(2,3,1)(4,5)\"` and returns an instance of `AbstractPermutation`.
>2. Find about string macros in julia documentation and turn such function into a **string macro** so that writing `perm\"(2,3,1)(4,5)\"` produces `Permutation([2,3,1,5,4])`.
"

# ╔═╡ acf34ce7-45af-4de0-81c0-fa50948584ee
md"
## Generating all permutations in a group
Suppose that we're given a set of permutations `S`. What is the group generated by `S`? How can generate __all elements__ in `G = ⟨S⟩`? 

Previously we were acting via `^` on single numbers like, e.g. `orbit_plain([σ, τ], 1, ^)` produces internally
```julia
	1^σ
	1^τ
	(1^σ)^σ
	(1^σ)^τ
	...
```
to obtain all elements in the orbit of `1`.

So if we replace `1` by `e` (the group identity) and `^` by `*`, the call `orbit_plain([σ, τ], e, *)` will compute
```julia
	e*σ
	e*τ
	(e*σ)*σ
	(e*σ)*τ
	...
```
creating all possible finite products of `σ` and `τ` i.e. obtaining the whole group generated by `S = [σ, τ]`.
"

# ╔═╡ 9838d4b1-da7a-4b6a-8e18-a32ac465805c
let σ = Permutation([2,3,4,1]), τ = Permutation([2,1])
	S = [σ, τ]
	@info S
	e = one(σ)
	orbit_plain(S, e, *)
end

# ╔═╡ 19367a34-9d88-4dbb-baed-4cea5b0a5eac
md"
# Transversals

Let `G = ⟨S⟩` and `x ∈ Ω` be a point, where `G` acts on `Ω` as usual (through `^`)
and let `Δ` be the orbit of `x`, i.e.

$$\Delta = (x, x^{g}, x^{h}, x^{gh}, \ldots )$$
(considered as __ordered set__).

**Definition**: A **transversal** is either
* the set of representatives of the coset set
$$
\operatorname{Stab_G}(x)\setminus G =\{
\operatorname{Stab_G}(x)e, \operatorname{Stab_G}(x)g, \operatorname{Stab_G}(x)h, \operatorname{Stab_G}(x)gh, \ldots \},$$
* the set `T` of group elements which takes `x` to consecutive elements (considered as __ordered set__) in $x^G$:
$$(e, g, h, gh,\ldots)$$.

> **Exercise 3**: Modify `orbit_plain` algorithm to compute the transversal as well. When given a point `y` in the orbit tansversal `T` should be able to determine `g ∈ G` which takes `x` to `y`. Recall that we denote this by saying that `T[y] = g`.
>
>_Tip_: For transversals use julias `Dict` dictionary (hashmap) structure. 
"

# ╔═╡ f52cb4dd-03d8-4526-880c-4aaad81412ab
function orbit_transversal(S, x, action=^)
	@assert !isempty(S) # groups need generators
	
end

# ╔═╡ 2fa081db-4ae0-4af6-b513-65d32c3ff856
let σ = Permutation([1,3,4,2]), τ = Permutation([1,2,4,5,3])
	orbit_transversal([σ, τ], 2)
end

# ╔═╡ 8acfbaf5-498a-473c-b03a-5eab478ac3b3
md"
## Schreier Vectors aka factored transversals
Suppose that `S = [s₁, …, sₖ]`. The aim now is, instead of storing actual generators in the transversal, to store only generator _indicies_, i.e. instead of
```julia
[e, s₂, s₁, s₂]
```
store only
```julia
[2, 1, 2]
```
The former requires  

	n*degree(s)*sizeof(Int) = n

bytes (where `n` is the ~length of the orbit) whereas the latter needs only

    n*sizeof(Int) = n*8

bytes, which is **independent** on the degree of the permutations!
The price we pay is that we store the elements in _factored_ form, so whenever asked for a coset representative we need to perform ~`n` multiplications to recover it.

Of course we also need to keep `S` around.
"

# ╔═╡ d20d14a4-3414-453d-943f-c760465d0ba7
md"
### Factor group elements
Let us try to store factorisation of representatives in the transversal.
Thus this time we start by saying that
```julia
T = Dict(x => [one(first(S))])
```
will hold lists of elements (starting with the identity) and that 
```julia
T[γ] = [T[δ]; s]
```
the next point in the transversal points to the factored representation of the previous the the new generator `s` added at the end.
"

# ╔═╡ 23122d5c-8545-43b9-a33a-2da78a46538a
function orbit_transversal_exp(S, x, action=^)
	@assert !isempty(S) # groups need generators

end

# ╔═╡ cc0fa689-6d78-4489-9faf-c4ef1b5dc762
orbit_transversal_exp([σ, τ], 1)

# ╔═╡ c73c88f0-a7ec-4260-af2a-665d1fadc150
let σ = Permutation([2,3,4,1]), τ = Permutation([2,1])
	S = [σ, τ]
	x = one(σ)
	
	orbit_transversal_exp(S, x, *)
end

# ╔═╡ 8951b592-0554-45c5-81b8-f1eac7d372dd
function orbit_Schreier(S, x, action=^)
    @assert !isempty(S) # groups need generators

end

# ╔═╡ b6669b69-53f2-4ef5-a17d-b45a9403a523
S, (Δ, T) = let σ = Permutation([2,1,4,3]), τ = Permutation([1,3,4,2])
	S = [σ, τ]
	@info S
	x = one(σ)
	
	S, orbit_Schreier(S, 2, ^)
end

# ╔═╡ c4c22682-4bbb-4d6d-a9a5-11afe67f200d
md"
Now, given such _Schreier Vector_ (but is it really a vector?) let's reconstruct a coset representative. I.e. given
 * `Δ` the orbit of `x` under `⟨S⟩`
 * `T` the factored transversal (=_Schreier Vector_)
 * `y ∈ Δ`
how to reconstruct the coset representative corresponding to `y`?

The answer is to walk the factored transversal __backward__`. Here's this in _pseudo-code_:
```julia
let current_point = y
	coset_rep = e
	while current_point ≠ x
		s = ... # s sends some previous point on the orbit to the current one
	    current_point = current_point^inv(s) # shift current one to the previous one
		# accumulate the change
		coset_rep = s * coset_rep
		# observe: coset_rep sends current_point to y.
	end
	coset_rep
end
```
>**Exercise 4**: Implement this function as
```julia
\"\"\"
	representative(S, Δ, T, y[, action=^])
Compute a representative `g` of left-coset `Stab_G(x)g` corresponding to point `y ∈ Δ` in the orbit of `x`.
## Input
* `S` a set of generators for `G = ⟨S⟩`
* `Δ` the orbit of `x` under the action of `G`
* `T` factored transversal for `Δ`
* `y` a point in `Δ`.
## Output
* `r ∈ G` such that `action(x, r) == y`. 
\"\"\"
function representative(S, Δ, T, y)
	...
end
```
Are all arguments actually needed?

> **Exercise 5**: Design structs for _orbits_, _transversals_ and _Schreier Vectors_.
> What are the common operations (=methods) we used so far?
> Can you think of a \"unifying\" architecture for all three of these objects?
"

# ╔═╡ 00000000-0000-0000-0000-000000000001
PLUTO_PROJECT_TOML_CONTENTS = """
[deps]
"""

# ╔═╡ 00000000-0000-0000-0000-000000000002
PLUTO_MANIFEST_TOML_CONTENTS = """
# This file is machine-generated - editing it directly is not advised

julia_version = "1.7.2"
manifest_format = "2.0"

[deps]
"""

# ╔═╡ Cell order:
# ╟─b1c7b4d8-c3d8-11ec-1936-2bbc4338d17a
# ╟─694eedcf-fc88-4c98-a508-49d51e95e307
# ╠═423e67fc-a756-4ba7-8e4d-fabfb7e22045
# ╠═57982949-1cb9-4077-afd7-444fb42f0fec
# ╠═261f2777-c2cc-498e-a7ef-a819f779344c
# ╠═9b3ef828-f64c-42b5-a7d8-ed7d2e0f96a9
# ╠═18121dc3-78d2-4334-b1bb-9b3cba02d730
# ╟─4118ac8d-3e55-4717-ac1f-98a3446b5eff
# ╟─acf34ce7-45af-4de0-81c0-fa50948584ee
# ╠═9838d4b1-da7a-4b6a-8e18-a32ac465805c
# ╟─19367a34-9d88-4dbb-baed-4cea5b0a5eac
# ╠═f52cb4dd-03d8-4526-880c-4aaad81412ab
# ╠═2fa081db-4ae0-4af6-b513-65d32c3ff856
# ╟─8acfbaf5-498a-473c-b03a-5eab478ac3b3
# ╟─d20d14a4-3414-453d-943f-c760465d0ba7
# ╠═23122d5c-8545-43b9-a33a-2da78a46538a
# ╠═cc0fa689-6d78-4489-9faf-c4ef1b5dc762
# ╠═c73c88f0-a7ec-4260-af2a-665d1fadc150
# ╠═8951b592-0554-45c5-81b8-f1eac7d372dd
# ╠═b6669b69-53f2-4ef5-a17d-b45a9403a523
# ╟─c4c22682-4bbb-4d6d-a9a5-11afe67f200d
# ╟─00000000-0000-0000-0000-000000000001
# ╟─00000000-0000-0000-0000-000000000002
